## Компиляция и запуск

    ghc -O2 --make -fforce-recomp august.hs
    ./august ../bigmatrix > result
    diff result ../pi1000000.txt

## Запуск на машине с конфигурацией pc1.conf

Not tested yet.

## Описание алгоритма

Наш алгоритм опирается на особенности представления матриц в Haskell, которые по сути являются массивами массивов. Если бы мы шли прямым путем и сравнивали области матрицы поочередно с каждым из символов, то каждый раз нам бы пришлось выделять область из пяти строк массива, по три элемента в каждой. Например, в следующей матрице с всего лишь двумя символами внутри

    λ: matrix
    [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]
    , [ 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 ]
    , [ 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ]
    , [ 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 0 ]
    , [ 0 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 ]
    , [ 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 0 ]
    , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]
    ]

в общем имеется `7 x 3 = 21` область, где мог бы располагаться символ. Операция нахождения области матрицы слишком дорогостоящая, чтобы идти таким путем. Мы поступим по-другому и, во-первых, транспонируем матрицу

    λ: transpose it
    [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ]
    , [ 0 , 1 , 0 , 0 , 0 , 1 , 0 ]
    , [ 0 , 1 , 1 , 1 , 1 , 1 , 0 ]
    , [ 0 , 0 , 0 , 0 , 0 , 1 , 0 ]
    , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ]
    , [ 0 , 1 , 0 , 1 , 1 , 1 , 0 ]
    , [ 0 , 1 , 0 , 1 , 0 , 1 , 0 ]
    , [ 0 , 1 , 1 , 1 , 0 , 1 , 0 ]
    , [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ]
    ]

уменьшив число строк в выделяемой области с пяти до трех (но уже по пять элементов в каждой). Во-вторых учтем, что хоть всего у нас 10 символов, но их столбцы повторяются, образуя множество из 9 возможных вариантов. Столбцы, не входящие в это множество, можно сразу отсеять. В отношении транспонированной матрицы это значит, что нам не надо выделять более одной строки, а достаточно рассмотреть для нее подпоследовательности из пяти элементов, откинув те, что не могут быть столбцами символов. Результат для нашей матрицы выглядит так:

    λ: map (symbolFstIndeces . zip [0..]) it
    [ [] , [ 1 ] , [ 1 ] , [ 1 ] , [] , [ 1 ] , [ 1 ] , [ 1 ] , [] ]

где каждый из под-массивов соответствует столбцу исходной матрицы `matrix` и содержит индексы строк для вероятных положений символов. Символы состоят из трех столбцов, поэтому каждый из индексов должен повторяться для трех соседних столбцов. Что дает нам координаты (индексы строки и столбца)

    λ: symbolSndIndeces $ zip it [0..]
    [ ( 1 , 1 ) , ( 1 , 5 ) ]

Как мы видим, еще не сделав проверку на символ, мы отбросили подавляющее большинство областей матрицы. Последний этап --- это проверка соответствия области одному из символов, но не для изначальных 21-ой области, а всего лишь для двух из них.

    λ: findSymbols (transpose matrix) it
    [ 1 , 2 ]

С ростом размера матрицы выгода от нашего подхода еще более
повышается.
